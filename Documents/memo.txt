
- 塗りやストロークのないノードは画像を出力しない
- 対応する画像が存在しないノードは、TextureIdを持たせない
- コンポーネントに対して塗りなどをオーバーライドしていないノードは、１度しか画像を出力しない。
  - そのようなノードのTextureIdは、全て同じになる。

以上のような処理のためにContext的なオブジェクトが必要かも。
  ノードID → テクスチャID
の対応付けができるハッシュマップが必要。
ハッシュマップに自分のIDが無いようなノードは、TextureIdを持たせない

この前提があるため、ノードの構築は画像の構築より後にするべき。
それが無理なら、全ての解析より先に、ハッシュマップを構築するための解析を走らせるという手もありそう。


コンポーネントがキャンバスに含まれている場合に有効な機能として、同じ画像を複数出力しない機能を提供する。
まず、あるノード(A)の先祖のうち、タイプが"INSTANCE"である最初のノードに対応するコンポーネントを探す。
次にコンポーネントから、Aと同じ場所まで辿っていき、それをBと呼ぶ。
Bの描画とAの描画が同じであれば、画像の出力をしないことにする。

あるいは、ノードIDを活用する。
タイプが"COMPONENT"であるノードを最初に収集し、その子ノードに至るまで、ＩＤを突き止める。
そのIDからオブジェクトへアクセスできるようにする。
インスタンス側はIDの末尾(?)にコンポーネントと同じ文字列を含むので、それを用いてマッチさせる。

## インスタンスの子孫からコンポーネントへ

`I2:197;3:308;3:141;2:120` などといったIDを持つ子孫からなら、

自分がINSTANCEなら、対応するCOMPONENTを探せる。(2:120をスタックに積む)
さもなくば、親がINSTANCEなら、対応するCOMPONENTを探せる。(3:141をスタックに積む)
さもなくば、その親がINSTANCEなら、対応するCOMPONENTを探せる。(3:308をスタックに積む)
このまま最初にヒットするまで続ける。
ヒットしたなら、求めるノードのIDは <componentID>;<スタックから順に>
自分自身も親もINSTANCEではない(先祖要素がヒットした)場合、先頭にIを付ける。

COMPONENTに当たってしまったら、自分自身が探していたノードであると分かる。
AのIDが先頭に`I`を持っているならば、コンポーネントに当たることはないだろう。

### IDについて

https://qiita.com/mito_log/items/26c0ac1adf486681b34d

### 再考

`I2:197;3:308;3:141;2:120` はどうやら、最も上位のINSTANCEのIDが `2:197`であることを示しているようだ。
ここから察するに、最上位のIDだけを置き換えればコンポーネント内でのIDを求められそうだ。

`2:197` に対するコンポーネントのIDが `2:134` であった場合、求めるIDは `2:134;3:308;3:141;2:120` であると言える。
ただし、求めるノードからコンポーネントまでの間にINSTANCEが挟まっている場合は先頭にIを付ける必要がある。

### 再考

おそらく、 `I2:197;3:308;3:141;2:120` の先頭をひとつ外すと、それがコンポーネントとしての自分自身であるっぽい？これは少なくとも、先頭に至るまでのID列が全てINSTANCEである場合において成り立つ。
そうでない場合はどうなるのだろう……

p.s. 「コンポーネントの一部としての自分自身」のことを言ってる？

## 再考

- 塗りやストロークのないノードは画像を出力しない
- 対応する画像が存在しないノードは、TextureIdを持たせない
- コンポーネントに対して塗りなどをオーバーライドしていないノードは、１度しか画像を出力しない。
  - そのようなノードのTextureIdは、全て同じになる。

コンポーネントの解析　→　画像の構築　→　ノードの構築

という順番で行うことで実現できそう。
